# 機能仕様: エージェントモード

**仕様ID**: `SPEC-ba3f610c`
**作成日**: 2026-01-22
**ステータス**: 承認済み
**カテゴリ**: Porting
**入力**: ユーザー説明: "エージェントモード: マスターエージェント（gwt内蔵LLM、既存AI要約と同じAPI設定共有）がユーザーと対話し、タスクを完全自律的に分割・計画し、複数のサブエージェント（Claude Code等）をtmux制御でオーケストレーションする新機能。"

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー 1 - モード切り替えと基本対話 (優先度: P1)

開発者がブランチモードで`Tab`を押すと、エージェントモードに切り替わり、マスターエージェントとの対話画面が表示される。ユーザーは自由形式でタスクを入力し、マスターエージェントがタスクを分析・計画を応答する。

**この優先度の理由**: エージェントモードへの入口であり、マスターエージェントとの対話がすべての機能の基盤となる。

**独立したテスト**: ブランチモードから`Tab`を押し、エージェントモード画面でタスクを入力して応答を受け取ることで検証できる。

**受け入れシナリオ**:

1. **前提条件** ブランチモードが表示されている、**操作** `Tab`を押す、**期待結果** エージェントモードに切り替わり、チャット画面が表示される
2. **前提条件** エージェントモードが表示されている、**操作** `Tab`を押す、**期待結果** ブランチモードに戻る
3. **前提条件** AI設定が無効（エンドポイントまたはモデル未設定）、**操作** エージェントモードに切り替え、**期待結果** 設定促進メッセージが表示される
4. **前提条件** エージェントモードが表示されている、**操作** 「認証機能を実装して」と入力、**期待結果** マスターエージェントがタスク分析と実行計画を応答
5. **前提条件** エージェントモードでタスクが実行中、**操作** `Tab`でブランチモードに切り替え、**期待結果** タスクはバックグラウンドで継続、ブランチモードに切り替わる

---

### ユーザーストーリー 2 - タスク分割とWorktree自動作成 (優先度: P1)

マスターエージェントがユーザーのタスクを分析し、必要に応じて複数のサブタスクに分割する。各サブタスクに対して、LLMが判断したWorktree戦略に基づいて`agent/`プレフィックス付きブランチとworktreeを自動作成する。

**この優先度の理由**: 自律的なタスク分割とWorktree管理がエージェントモードの核心機能であり、サブエージェント実行の前提条件となる。

**独立したテスト**: タスクを入力し、マスターエージェントがタスクを分割してworktreeを作成することを確認することで検証できる。

**承認方式**: 計画一括承認。マスターエージェントがタスク計画全体を提示し、ユーザーが1回承認すれば、以降のWT作成・サブエージェント起動・テスト検証・PR作成はすべてマスターエージェントが自律実行する。ユーザーは対話画面でいつでも介入・中止が可能。

**受け入れシナリオ**:

1. **前提条件** マスターエージェントがタスク計画を策定、**操作** ユーザーが計画全体を承認、**期待結果** `agent/`プレフィックス付きブランチとworktreeが作成され、サブエージェント起動まで自律実行される
2. **前提条件** 独立した複数タスク、**操作** マスターエージェントがLLM判断で戦略決定、**期待結果** 各タスクに別々のworktreeが作成される
3. **前提条件** 依存関係のあるタスク、**操作** マスターエージェントがLLM判断で戦略決定、**期待結果** 依存タスクは先行タスクのコミットを後続ブランチにmergeしてから順次実行される
4. **前提条件** ブランチ名の命名、**操作** worktree作成、**期待結果** `agent/task-description`のような意味のある名前が付けられる
5. **前提条件** ユーザーが計画を拒否、**操作** 拒否理由を入力、**期待結果** マスターエージェントが計画を再策定する

---

### ユーザーストーリー 3 - サブエージェント起動と指示 (優先度: P1)

マスターエージェントがサブエージェント（Claude Code等）をtmuxペインで起動し、`tmux send-keys`でプロンプトを送信する。プロンプトには「タスクが完了したらqで終了して」という指示を含める。

**この優先度の理由**: サブエージェントへの指示がタスク実行の実体であり、エージェントモードの価値を実現する核心機能。

**独立したテスト**: タスク実行を開始し、サブエージェントがtmuxペインで起動してプロンプトを受け取ることを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** worktreeが作成済み、**操作** タスク実行開始、**期待結果** tmuxペインでサブエージェント（Claude Code等）が起動
2. **前提条件** サブエージェントが起動、**操作** マスターエージェントがプロンプト送信、**期待結果** `tmux send-keys`でプロンプトが入力される
3. **前提条件** プロンプト送信、**操作** プロンプト内容を確認、**期待結果** タスク指示と「完了したらqで終了」の指示が含まれる
4. **前提条件** 複数サブエージェントを起動、**操作** 並列実行、**期待結果** 各エージェントが別々のtmuxペインで動作

---

### ユーザーストーリー 4 - サブエージェント完了検出 (優先度: P1)

マスターエージェントがサブエージェントの完了を検出する。Claude CodeはHookのStop経由、他のエージェントはtmux複合方式（プロセス終了監視 + 出力パターン監視 + アクティビティ監視）で検出する。

**この優先度の理由**: 完了検出なしにはタスクの進行管理と次のステップへの移行ができない。

**独立したテスト**: サブエージェントがタスクを完了し、マスターエージェントが完了を検出して次のアクションに移行することを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** Claude Codeがサブエージェントとして動作中、**操作** タスク完了でqを押す、**期待結果** Hook経由で完了が検出される
2. **前提条件** Claude Code以外のエージェントが動作中、**操作** プロセスが終了、**期待結果** tmux pane_dead等で完了が検出される
3. **前提条件** tmux出力パターン監視、**操作** 特定の完了パターンが出力、**期待結果** capture-paneで完了が検出される
4. **前提条件** 複合方式での監視、**操作** いずれかの条件を満たす、**期待結果** 完了が検出され、マスターエージェントに通知される

---

### ユーザーストーリー 5 - 成果物検証と統合（PR経由） (優先度: P2)

サブエージェント完了後、マスターエージェントがテスト実行による自動検証を行い、パスした場合にPRを作成して成果物を統合する。コンフリクトが発生した場合はサブエージェントに解決させる。

**この優先度の理由**: 成果物の品質検証と統合はフルサイクルに必須だが、基本的なタスク実行が動作してからの改善項目。

**独立したテスト**: 複数タスク完了後、テスト検証を経てPRが作成されマージされることを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** サブエージェントがタスク完了、**操作** マスターエージェントがテスト実行を指示、**期待結果** サブエージェントが当該worktreeでテスト（`cargo test`等）を実行する
2. **前提条件** テストがパス、**操作** 成果物統合フェーズ開始、**期待結果** worktreeからPRが作成される
3. **前提条件** テストが失敗、**操作** マスターエージェントが検出、**期待結果** サブエージェントに修正を指示し再テスト（最大3回まで）
4. **前提条件** 複数PRが存在、**操作** マージ、**期待結果** GitHub上でマージされる
5. **前提条件** マージ時にコンフリクト発生、**操作** マスターエージェントが検出、**期待結果** サブエージェントにコンフリクト解決を指示

---

### ユーザーストーリー 6 - 失敗ハンドリング (優先度: P2)

サブエージェントがタスクに失敗した場合（エラー終了、タスク未達成）、マスターエージェントがLLM判断で対応する（リトライ、代替アプローチ、ユーザーへの相談など）。

**この優先度の理由**: エラーハンドリングは堅牢性に必要だが、基本フローが動作してからの改善項目。

**独立したテスト**: サブエージェントが失敗し、マスターエージェントが適切に対応することを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** サブエージェントがエラー終了、**操作** マスターエージェントが検出、**期待結果** LLM判断で対応策を決定（リトライ/代替/相談）
2. **前提条件** タスク未達成（テスト失敗等）、**操作** マスターエージェントが検出、**期待結果** LLM判断で修正指示を送信
3. **前提条件** 複数回の失敗、**操作** マスターエージェントが判断、**期待結果** ユーザーに相談または代替アプローチを提案

---

### ユーザーストーリー 7 - セッション永続化と再開 (優先度: P2)

エージェントモードのセッション状態（タスク一覧、進捗、会話履歴）を完全永続化する。gwtを再起動しても途中のセッションを再開できる。

**この優先度の理由**: 長時間タスクの中断・再開に必須だが、基本フローが動作してからの改善項目。

**独立したテスト**: セッションを中断して再起動し、再開できることを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** タスク実行中、**操作** gwtを終了、**期待結果** セッション状態が`~/.gwt/sessions/`に保存される
2. **前提条件** セッションが保存されている、**操作** gwtを再起動、**期待結果** 前回のセッションを再開できる
3. **前提条件** セッション再開、**操作** 継続実行、**期待結果** 中断前の状態から継続できる
4. **前提条件** 会話履歴が保存されている、**操作** セッション再開、**期待結果** 過去の会話を参照できる

---

### ユーザーストーリー 8 - コンテキスト管理（要約圧縮） (優先度: P3)

タスクが大規模になりLLMのコンテキストウィンドウを超える可能性がある場合、完了タスクの情報を要約圧縮してコンテキストを管理する。

**この優先度の理由**: 大規模タスクへの対応に必要だが、基本的なタスクサイズでは不要。

**独立したテスト**: 長時間の大規模タスク実行後、コンテキストが圧縮されて継続動作することを確認することで検証できる。

**受け入れシナリオ**:

1. **前提条件** 対話が長くなりコンテキストが大きくなる、**操作** 継続して対話、**期待結果** 完了タスクの情報が要約圧縮される
2. **前提条件** 要約圧縮が実行される、**操作** 継続して対話、**期待結果** 重要な情報は保持されつつコンテキストウィンドウ内に収まる

---

### エッジケース

- サブエージェント起動中にtmuxセッションが切断された場合、どう復旧するか？
- 同一ファイルを複数サブエージェントが同時に編集しようとした場合、コンフリクト検出のタイミングは？（→ 依存関係のあるタスクはGit merge時に検出、独立タスクはPR統合時に検出）
- マスターエージェントのLLM API呼び出しがタイムアウトした場合、進行中のタスクはどうなるか？
- セッション復元時に参照していたworktreeが削除されていた場合、どう対処するか？
- テスト検証で3回連続失敗した場合のタスク状態遷移（→ Failed + ユーザー通知）
- 先行タスクのmergeがコンフリクトした場合の後続タスクの扱い（→ サブエージェントに解決を指示）

## 詳細仕様 *(必須)*

### AI設定未構成時の扱い

- AI設定が有効とみなされる条件は「endpointとmodelが設定済みで、AIClientの初期化に成功すること」。
- AI設定が無効の場合でもエージェントモード画面は表示するが、送信入力は無効化する。
- 画面内に英語のエラーメッセージ（例: "AI settings are required"）と、既存のAI設定ウィザードへ遷移する導線を表示する。
- AI設定が有効化されたら、入力と実行を即時再開できる。

### Spec Kit内蔵化

- gwt自体にSpec Kitの機能を**LLMプロンプトテンプレート**として組み込む。
- 組み込む機能: specify（仕様策定）、plan（計画策定）、tasks（タスク生成）、clarify（曖昧さ解消）、analyze（整合性分析）。
- 各機能はLLMプロンプトテンプレートとしてRustの`include_str!`マクロでバイナリにコンパイル時埋め込みする。
- テンプレートの更新はgwtのリリースに含める。
- マスターエージェントがLLM経由で各テンプレートを実行する。
- 成果物（spec.md, plan.md, tasks.md）は既存と同じ`specs/SPEC-XXXXXXXX/`ディレクトリに保存する。
- SPEC IDはUUID 8桁で自動生成する（既存の命名規約に準拠）。
- Spec Kit機能は**モード横断**で利用可能とする:
  - エージェントモード: マスターエージェントが自動的にワークフローを実行
  - ブランチモード: ショートカットキーでSpec Kitワークフローを起動可能

### Spec Kit連携ワークフロー（エージェントモード）

- マスターエージェントは以下のフローでSpec Kitを自動的に組み込む:
  1. **要件収集フェーズ**: ユーザーの機能要求 + リポジトリディープスキャンをもとに、LLMで仕様・要件を洗い出す（clarify相当）
  2. **仕様策定**: マスターエージェントがspec.mdを自動生成する（specify相当）
  3. **計画策定**: 仕様に基づいてplan.mdを自動生成する（plan相当）
  4. **タスク生成**: tasks.mdを自動生成する（tasks相当）
  5. **一括承認**: 仕様概要 + 計画 + タスク一覧をチャットでユーザーに提示し、一括承認を得る
  6. **実行**: 承認後、各タスクをサブエージェントに割り当てて自律実行する
- 仕様の承認は計画の一括承認に含まれる（別ステップは設けない）。
- サブエージェントはTDDで実装を行う（テスト作成→実装→テストパスの順）。

### タスク分割の入出力仕様

- タスク生成はSpec Kitの`/speckit.tasks`の出力形式に準拠する。
- マスターエージェントはSpec Kitが生成したtasks.mdの各タスクを、サブエージェント単位に割り当てる。
- 割り当て時の判断:
  - 独立したタスクは別々のWorktree+サブエージェントに割り当てる
  - 依存関係のあるタスクは同一Worktreeで順次実行、またはGit merge経由で連携する
- worktree_strategyはマスターエージェントがLLMで判断する（`new`または`shared`）。
- タスクIDはSpec Kitのtasks.md内のID体系に準拠する。
- マスターエージェントはタスク分割時に各タスクが**1サブエージェントで完遂可能な粒度**であることを保証する。粒度が大きすぎる場合はさらに分割する。
- テストフレームワークが未セットアップのリポジトリでは、テスト環境のセットアップもタスクに含める。

### Worktree/ブランチ命名と作成ルール

- ブランチ名は必ず`agent/`プレフィックスを付ける。
- タスク名からブランチ名を生成する際のルール:
  - 英小文字化する
  - 空白/連続スペースは`-`に置換する
  - `/`と`\`は`-`に置換する
  - 記号は除去し、英数字・ハイフン・アンダースコアのみ許可する
  - 長さは64文字以内とする
- 既に同名ブランチまたは同名worktreeパスが存在する場合は`-2`,`-3`の連番を付与する。
- worktree作成パスは`{repo_root}/.worktrees/{sanitized_branch_name}`を使用する。
- ブランチの起点は「エージェントモード開始時点の現在ブランチ」とする。

### オーケストレーションループ（イベント駆動）

- マスターエージェントの思考ループは**イベント駆動**で実装する。
- 以下のイベントがLLMコールをトリガーする:
  - サブエージェント完了検出（Hook / tmux / プロセス終了）
  - サブエージェント失敗検出（エラー終了、テスト失敗）
  - ユーザーからのチャット入力（新しい指示、質問への回答、介入）
  - セッション開始（初回タスク入力）
- 各イベントに対してLLMが「次のアクション」を決定する:
  - 次のタスクのサブエージェント起動
  - テスト検証の開始
  - PR作成の開始
  - ユーザーへの質問/報告
  - Git mergeの実行（依存タスク間）
  - セッション完了（クリーンアップ開始）
- イベント間はマスターエージェントはアイドル状態（LLMコール不要）。

### tmux要件と非tmux時の挙動

- `$TMUX`が未設定、またはtmuxコマンド実行に失敗した場合はエージェントモード実行を拒否する。
- 画面には英語で"tmux is required"などのメッセージと再起動手順を表示する。
- 既存のブランチモード操作は継続可能とする。

### リポジトリ理解（ディープスキャン）

- マスターエージェントはタスク分割前に、リポジトリの構造を深くスキャンしてLLMに渡す。
- スキャン対象:
  - CLAUDE.md（プロジェクト規約・開発ワークフロー）
  - ディレクトリツリー（主要ディレクトリの一覧）
  - Cargo.toml / package.json 等のメタファイル（依存関係・プロジェクト構成）
  - 主要ソースコードの概要（エントリポイント、モジュール構成）
  - 既存のスペック一覧（specs/ディレクトリ）
- スキャン結果はシステムプロンプトの一部としてLLMに渡す。
- スキャンはセッション開始時に1回実行し、キャッシュする。

### サブエージェント起動プロンプト規約

- プロンプトには必ず「完了したらqで終了して」を含める。
- Claude Code以外のエージェントには「終了前に`GWT_TASK_DONE`を出力する」指示を追加する。
- プロンプトの豊かさはマスターエージェントがLLMで**アダプティブに判断**する:
  - 単純なタスク: タスク指示のみ
  - 複雑なタスク: CLAUDE.md内容、他タスクの概要、ユーザーの技術判断結果、ディレクトリ構成等を含む
- 判断基準: タスクの依存関係数、記述の複雑さ、技術判断の有無。
- すべてのサブエージェントプロンプトには、CLAUDE.mdから抽出したコーディング規約（命名規則、スタイル、lintルール等）を含める。これにより複数サブエージェント間のコード一貫性を担保する。

### サブエージェント並列実行制御

- 同時実行数の上限はマスターエージェントがLLMで判断する。
- 判断基準: タスクの独立性、依存関係、リポジトリの規模、タスクの複雑さ。
- LLMは「この計画で最適な並列度はN」という判断を計画策定時に含める。
- 並列度の変更は実行中にも動的に可能（例: タスク完了により新たな独立タスクが解放された場合）。

### 途中経過報告

- マスターエージェントは定期的（2分間隔を目安）にサブエージェントの状態をチェックし、チャットに進捗を報告する。
- 報告内容: 各タスクの現在の状態（実行中/完了/失敗）、実行時間、直近のtmux capture-paneからの要約。
- 定期報告はLLMコールを伴わない軽量な処理とし、tmux list-panesとキャプチャのみで構成する。

### サブエージェント完了検出の条件

- Claude CodeはHook Stopを最優先で使用し、失敗時はtmux複合方式へフォールバックする。
- tmux複合方式の判定条件は以下のいずれか:
  - プロセス終了（pane_deadまたはPID終了）
  - 出力パターン検出（`GWT_TASK_DONE`）
  - tmux send-keysによる完了確認（マスターがサブエージェントに状態確認クエリを送信）
- アイドルタイムアウト（5分）は廃止する。理由: サブエージェントの「ユーザー入力待ち」（パーミッション確認等）とタスク完了を区別できないため。
- サブエージェントは全自動モードで起動し、入力待ちを最小化する:
  - Claude Code: `--dangerously-skip-permissions`フラグで起動
  - Codex: `--full-auto`フラグで起動
  - Gemini: 利用可能な自動承認フラグで起動
  - その他: ツール固有の自動モードフラグを使用

### マスターエージェントLLM障害時の挙動

- マスターエージェントのLLM APIがダウン（レートリミット、サービス障害等）した場合:
  - 実行中のサブエージェントはそのまま続行する（独立プロセスのため）。
  - ユーザーにチャットでAPI障害を通知する。
  - マスターエージェントはエクスポネンシャルバックオフでAPIリトライする。
  - API復旧後、サブエージェントの現在状態を再取得してオーケストレーションを再開する。

### 承認フローとドライランモード

- マスターエージェントはタスク分割後、計画全体をユーザーに提示する。
- ユーザーが承認（Enter or "y"）すると、以降のWT作成・サブエージェント起動・テスト検証・PR作成はすべて自律実行される。
- ユーザーが拒否した場合、マスターエージェントはフィードバックを受けて計画を再策定する。
- 実行中でもユーザーはチャット入力で介入・中止指示が可能。
- **ドライランモード**: ユーザーが「計画だけ見せて」等の指示をした場合、マスターエージェントは仕様策定・計画・タスク生成までを実行し、実行には進まない。ドライラン結果を確認後、ユーザーが「実行して」と指示すれば通常フローに移行する。

### セッションの継続判断

- 完了済みセッションに関連する追加依頼（例: 「認証にMFAも追加して」）があった場合、マスターエージェントがLLMで「前回の続き」か「新規セッション」かを判断する。
- 判断基準: 既存のspec.md/plan.mdとの関連度、既存ブランチの状態、変更の規模。
- 「続き」と判断した場合: 既存のスペックを拡張し、追加タスクを生成する。
- 「新規」と判断した場合: 新しいセッションとして開始する。

### マスターエージェントの責務範囲

- マスターエージェントは「薄いオーケストレータ」を基本とし、タスク分割・進捗管理・成果物統合を担う。
- ただし、技術的な選択肢が存在する場合（例: JWT vs OAuth、ライブラリ選定など）、マスターエージェントは自律的に判断せず、**デフォルト推奨付きでユーザーに質問して確認を取る**。
- ユーザーの回答はサブエージェントへのプロンプトに含めて、技術判断を伝達する。
- 選択肢が明白でない（自由記述が必要な）場合もチャットで質問する。

### マスターエージェントのスコープ

- マスターエージェントは**機能実装単位**で存在する。1つの機能要求に対して1つのマスターエージェントセッションが対応する。
- ユーザーが複数の独立した機能を依頼した場合、それぞれ独立したマスターエージェントセッションとして管理する。
- 複数セッションは**キュー方式**で処理する。実行は1セッションずつ行い、待機中のセッションはキューに入る。
- キューの順序はFIFO（先入れ先出し）を基本とする。

### エージェントモードUI

- エージェントモードは**チャットのみ**の単一画面で構成する。タスク状態はチャット内でマスターエージェントがテキストで報告する。
- 独立したタスクパネルは設けない。
- チャット画面の下部に入力エリア、上部にチャット履歴を表示する。
- キュー内の待機セッション数や現在のセッション名は、画面上部のステータスバーに表示する。

### ブランチモードとの連携

- エージェントモードが作成した`agent/`ブランチは、ブランチモードのリストに通常ブランチと同じく**完全表示**される。
- ユーザーはブランチモードで`agent/`ブランチを自由に操作（削除、マージ等）できる。
- ブランチモードで`agent/`ブランチが削除された場合、エージェントモード側は該当タスクのworktree参照が欠落した状態として検出し、セッション永続化の復元ルールに従って処理する（Failed/Paused）。
- 既存のコーディングエージェントサポート（SPEC-3b0ed29b: ブランチモードから手動でエージェントを起動する機能）とエージェントモードは**独立して共存**する。エージェントモードのサブエージェントはマスターエージェントが自動的に管理する。

### セッション強制中断

- ユーザーは**ショートカットキー（Esc）**で実行中のセッションを即時中断できる。
- 中断時の処理:
  1. 全サブエージェントのtmuxペインにSIGTERMを送信する
  2. サブエージェント停止を確認する（タイムアウト5秒）
  3. セッション状態を「Paused」として永続化する
  4. チャットに中断完了を表示する
- 中断したセッションは後から再開可能（セッション復元機能）。

### ログ記録

- マスターエージェントの全LLMコール（プロンプト + レスポンス）を既存のログシステム（SPEC-b9f5c4a1）に記録する。
- ログカテゴリ: `agent.master.llm`
- サブエージェントの起動/完了/失敗イベントも記録する（カテゴリ: `agent.sub`）。
- ログはJSON Lines形式で`~/.gwt/logs/<cwd>/gwt.jsonl.YYYY-MM-DD`に保存する。

### ユーザーへの質問UX（計画前質問フェーズ）

- マスターエージェントは計画提示前に「質問フェーズ」を設ける。
- このフェーズでは、Spec Kitのclarify（仕様の曖昧さ解消）と技術的選択の質問を**統合して一括提示**する。
- 各質問には**デフォルト推奨を付与**する。
- ユーザーはEnterキーで全デフォルトを採用できる（質問攻めを回避）。
- 質問フェーズ完了後、仕様策定→計画→タスク生成を自動実行する。

### 一括承認の提示内容

- 承認時には、spec.md / plan.md / tasks.md の**全文をチャット内に表示**する（スクロール可能）。
- 各ドキュメントはセクション区切りで視覚的に分離する。
- ユーザーは全文を確認した上で承認/拒否を行う。

### ブランチモードからのSpec Kit起動

- ブランチモード内で**インラインウィザード形式**でSpec Kitワークフローを起動できる。
- ショートカットキーでウィザードが開き、機能説明を入力するとSpec Kit（specify→plan→tasks）が実行される。
- 成果物は`specs/SPEC-XXXXXXXX/`に保存される。
- ウィザード完了後はブランチモードに戻る。

### コスト可視化

- マスターエージェントのLLM APIコール数と推定トークン数をTUI上に表示する。
- サブエージェントのコストはgwt側では追跡しない（各エージェントの責務）。
- コスト上限による実行停止機能は設けない（ユーザーの自己責任）。

### 信頼境界とサンドボックス

- Worktreeはサブエージェントのサンドボックスとして機能する。
- サブエージェントがWorktree内で行った操作（ファイル削除、大幅変更等）は、WT内に閉じているため破壊的操作の検出・防止は行わない。
- 成果物の品質はテスト実行による事後検証で担保する。

### 実行中の介入（ライブ介入）

- ユーザーが実行中にチャットで新しい要件・変更を伝えた場合、マスターエージェントはLLMで影響範囲を判定する。
- 影響を受けるタスクのみを停止し、影響を受けないタスクは続行する。
- 停止したタスクは、新しい要件を反映した再計画後にリスタートする。
- 影響判定のLLM入力: 現在のタスク一覧（名前・説明・状態）+ ユーザーの新しい指示。

### 成果物検証（テスト実行）

- サブエージェント完了検出後、マスターエージェントは同一worktree内でテスト実行をサブエージェントに指示する。
- テストコマンドはリポジトリのビルドシステムに基づいて自動判定する（例: Cargo.toml → `cargo test`、package.json → `npm test`）。
- テストがパスした場合のみPR作成に進む。
- テストが失敗した場合、マスターエージェントはサブエージェントに修正を指示する（最大3回まで再試行）。
- 3回失敗した場合はタスクを`Failed`とし、ユーザーに通知する。

### サブエージェント間コンテキスト共有（Git経由）

- 依存関係のあるタスクにおいて、先行タスクが完了しコミットされた場合、マスターエージェントは後続タスクのブランチに先行タスクのコミットをmergeする。
- merge手順:
  1. 先行タスクのworktreeでコミット・プッシュを確認する
  2. 後続タスクのworktreeに移動し、`git merge agent/<先行タスクブランチ>` を実行する
  3. mergeコンフリクトが発生した場合は後続サブエージェントに解決を指示する
- 並列実行される独立タスク間ではコンテキスト共有は行わない（依存関係がないため）。

### PR作成と統合条件

- PR作成の前提条件:
  - worktree内がクリーンであること
  - baseブランチに対して差分が存在すること
  - `gh`が利用可能で認証済みであること
- baseブランチは「エージェントモード開始時点の現在ブランチ」、headは`agent/...`ブランチとする。
- PRタイトル・本文はマスターエージェントがLLMでgit diffを読み取り、品質の高い内容を生成する。
  - タイトル: Conventional Commits形式に準拠
  - 本文: 変更内容の概要、影響範囲、テスト結果を含む
- PR作成に失敗した場合は統合を保留し、英語でユーザーに通知する。

### セッション永続化と復元

- 保存トリガー: 会話メッセージ追加、タスク状態変更、worktree作成/削除、サブエージェント状態変更。
- 保存は同一ディレクトリの一時ファイルへ書き出し後、原子的にリネームする。
- セッションファイルのパーミッションは0600、ディレクトリは0700を維持する。
- 起動時、未完了セッションが存在する場合は一覧を提示し、再開/破棄を選択できる。
- JSON破損時は`.broken`に退避して新規セッションを開始する。
- 参照worktreeが欠落している場合は該当タスクを`Failed`または`Paused`とし、再作成/再割当の選択肢を提示する。

### セッション完了とクリーンアップ

- セッションの「完了」は以下のすべてを満たした時点:
  1. 全タスクがCompleted状態
  2. 全PRがマージ済み（またはPR不要と判断）
  3. `agent/`ブランチと対応するWorktreeが自動削除済み
- クリーンアップ手順:
  1. 各worktreeで未コミット・未プッシュの変更がないことを確認する
  2. `git worktree remove`でWorktreeを削除する
  3. `git branch -d`でローカルの`agent/`ブランチを削除する
  4. リモートの`agent/`ブランチも削除する（PRマージ後）
- クリーンアップ失敗（未コミット変更がある等）の場合は、チャットでユーザーに通知して手動対応を促す。
- セッション完了後、キューに次のセッションがあれば自動的に開始する。

### コンテキスト要約（圧縮）条件

- 直近メッセージと未完了タスク情報は保持し、完了タスクと古い会話を要約対象とする。
- 目安となるトリガー:
  - モデルの最大コンテキストが取得できる場合: 推定トークンが最大の80%を超える前に要約
  - 取得できない場合: 最大16kトークンとみなし、12kトークン相当で要約
- 要約結果はシステムメッセージとして保存し、直近20メッセージは原文を保持する。

## 要件 *(必須)*

### 機能要件

- **FR-001**: システムは`Tab`キーでブランチモードとエージェントモードを切り替えできなければならない
- **FR-001a**: ブランチモード画面では、ブランチ詳細パネルとAI要約パネルを縦に並べて同時表示しなければならない（既存のTab切り替えは廃止）
- **FR-002**: システムはマスターエージェント（gwt内蔵LLM）を通じてユーザーと自然言語で対話できなければならない
- **FR-002a**: マスターエージェントはタスク計画全体を提示し、ユーザーの一括承認を得てから自律実行を開始しなければならない
- **FR-002b**: マスターエージェントは技術的な選択肢が存在する場合、自律判断せずユーザーに質問して確認を取らなければならない
- **FR-002c**: 実行中にユーザーが新しい要件・変更を伝えた場合、マスターエージェントはLLMで影響範囲を判定し、影響タスクのみ停止・再計画しなければならない
- **FR-003**: マスターエージェントはユーザーの自由形式タスク入力をもとに、Spec Kitワークフロー（仕様策定→計画→タスク生成）を自動実行しなければならない
- **FR-003a**: タスク生成にはSpec Kitの`/speckit.tasks`を使用しなければならない
- **FR-004**: システムは`agent/`プレフィックス付きブランチとworktreeを自動作成できなければならない
- **FR-005**: システムはtmux制御（send-keys, capture-pane等）でサブエージェントを起動・制御できなければならない
- **FR-006**: システムはClaude CodeのHook（Stop）経由で完了を検出できなければならない
- **FR-007**: システムはtmux複合方式（プロセス終了+出力パターン+アクティビティ）でClaude Code以外のエージェント完了を検出できなければならない
- **FR-008**: システムはPR経由で複数worktreeの成果物を統合できなければならない
- **FR-008a**: システムはサブエージェント完了後にテスト実行による成果物検証を行い、パス後にのみPR作成に進まなければならない
- **FR-009**: システムはコンフリクト発生時にサブエージェントに解決を指示できなければならない
- **FR-009a**: システムは依存関係のある後続タスク起動前に、先行タスクのコミットをGit merge経由で後続ブランチに統合しなければならない
- **FR-010**: システムはセッション状態を`~/.gwt/sessions/`に永続化できなければならない
- **FR-011**: システムは永続化されたセッションを復元して再開できなければならない
- **FR-012**: システムはコンテキストが大きくなった際に要約圧縮できなければならない
- **FR-013**: マスターエージェントは既存のAI要約機能と同じAPI設定（OpenAI互換API）を共有しなければならない。構造化出力（JSON）はプロンプトエンジニアリングで対応する
- **FR-014**: 複数の機能依頼はキュー方式で管理し、1セッションずつ順次実行しなければならない
- **FR-015**: マスターエージェントのLLM APIコール数と推定トークン数をTUI上で可視化しなければならない
- **FR-016**: エージェントモードが作成した`agent/`ブランチは、ブランチモードに完全表示し、ユーザーの自由な操作を許可しなければならない
- **FR-017**: gwt自体にSpec Kit機能（specify/plan/tasks/clarify/analyze）をLLMプロンプトテンプレートとして内蔵しなければならない
- **FR-018**: Spec Kit成果物は既存の`specs/SPEC-XXXXXXXX/`ディレクトリに保存しなければならない
- **FR-019**: Spec Kit機能はエージェントモードとブランチモードの両方から利用可能でなければならない
- **FR-020**: ドライランモード（計画のみ表示、実行なし）をサポートしなければならない
- **FR-021**: 完了済みセッションへの追加依頼時、マスターエージェントがLLMで「継続/新規」を判断しなければならない
- **FR-022**: サブエージェントプロンプトにCLAUDE.mdから抽出したコーディング規約を含め、コード一貫性を担保しなければならない
- **FR-023**: マスターエージェントは定期的（2分間隔目安）にサブエージェントの進捗をチャットに報告しなければならない
- **FR-024**: ユーザーはEscキーで実行中のセッションを即時中断し、全サブエージェントを停止できなければならない
- **FR-025**: マスターエージェントの全LLMコールを既存のログシステムに記録しなければならない

### 主要エンティティ

- **Session**: エージェントモードのセッション全体を表す。会話履歴、タスク一覧、進捗状態を含む
- **Task**: マスターエージェントが分割した個別のタスク。状態（pending/running/completed/failed）、依存関係、割り当てworktreeを持つ
- **SubAgent**: サブエージェント（Claude Code等）のインスタンス。tmuxペイン、worktree、状態を持つ
- **Conversation**: マスターエージェントとユーザーの対話履歴

## 成功基準 *(必須)*

### 測定可能な成果

- **SC-001**: ユーザーは`Tab`キーで1秒以内にモード切り替えができる
- **SC-002**: マスターエージェントは5秒以内に初回応答を返す
- **SC-003**: サブエージェントの完了検出は実際の完了から10秒以内に行われる
- **SC-004**: セッション永続化は状態変更から1秒以内に完了する
- **SC-005**: gwtクラッシュ後もセッションの99%が復元可能である

## 制約と仮定 *(該当する場合)*

### 制約

- tmux環境が必須（tmux外では使用不可）
- Claude Code以外のエージェントでは完了検出の精度が落ちる可能性がある
- LLM APIコストはユーザー責任で管理（制限機能なし）
- `agent/`プレフィックス以外のブランチは自動作成不可

### 仮定

- ユーザーは有効なLLM API設定（既存AI要約機能と共有）を持っている
- サブエージェント（Claude Code等）が正常にインストールされている
- tmuxが利用可能な環境で実行される

## 範囲外 *(必須)*

次の項目は、この機能の範囲外です：

- tmux以外の端末多重化ツール（screen等）のサポート
- LLM APIコスト管理・制限機能
- `agent/`以外のプレフィックスでのブランチ自動作成
- サブエージェント以外への作業委譲（外部サービス呼び出し等）
- リポジトリ知識の蓄積・学習（過去セッションからのパターン学習）

**注**: ブランチモードの画面構成変更（詳細/AI要約パネルの縦並び化）はFR-001aとして本仕様の範囲内に含まれる

## セキュリティとプライバシーの考慮事項 *(該当する場合)*

- LLM APIキーは既存のAI要約機能と同じ安全な方法で管理される
- セッションファイルにはタスク内容や会話履歴が含まれるため、適切なファイルパーミッションが必要
- サブエージェントへのプロンプトにセンシティブ情報が含まれる可能性がある

## 依存関係 *(該当する場合)*

- 既存のAI要約機能（SPEC-4b893dae）のAPI設定を共有
- 既存のtmuxマルチエージェントモード
- 既存のworktree管理機能
- Claude Code Hook機能（Stop）
- Spec Kit（`/speckit.specify`, `/speckit.plan`, `/speckit.tasks`）による仕様策定・計画・タスク生成

## 参考資料 *(該当する場合)*

- [既存AI要約機能仕様](../SPEC-4b893dae/spec.md)
- [tmux man page - send-keys](https://man7.org/linux/man-pages/man1/tmux.1.html)
